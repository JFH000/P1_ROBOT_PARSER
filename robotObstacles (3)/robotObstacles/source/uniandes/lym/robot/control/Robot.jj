/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi


 **/


options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
 
import java.awt.Point;
import java.io.*;
import java.util.*;

@SuppressWarnings("serial")
public class Robot 
{
  private static Console sistema;

  public static void createSistema(Console s) {
    sistema = s;
  }  

  private static RobotWorldDec world;
	
  void setWorld(RobotWorld w) {
	world = (RobotWorldDec) w;	
  }

  String salida=new String();



  private static final String CREATE_VARS = "createVar";
  private static final String ASSIGN_VAR = "assignVar";
  private static final String GET_VAR = "getVar";
  private static final String GO_TO = "goTo";
  private static final String MOVE_I = "move";
  private static final String TURN_I = "turn";
  private static final String FACE_I = "face";
  private static final String PICK_I = "pick";
  private static final String PUT_I = "put";
  private static final String JUMP_I = "jump";
  private static final String NOP_I = "nop";

  private static final String FACING_C = "facing";
  private static final String CAN_PUT = "canPut";
  private static final String CAN_PICK = "canPick";
  private static final String CAN_MOVE = "canMove";
  private static final String CAN_JUMP = "canJump";
  private static final String NOT_ = "not";

  private static final String LOOP_C = "loop";
  private static final String CONDITIONAL_C = "conditional";
  private static final String REPEAT_C = "repeat";
  private static final String PROCEDURE_DEF = "procedureDef";
  private static final String PROCEDURE_CALL = "procedureCall";

  
  private static Integer blockID = 0;
  private static Integer instructionID = 0;
  
  private static Map<String, Object> globalVars = new HashMap<>();
  private static Map<String, Object> procs = new HashMap<>();
  private static Map<Integer,Map<String, Object>> blocks = new HashMap<>();

	public static Integer getInstructionID() {
        instructionID++;
        return instructionID;
    }

	public static void createVars(ArrayList<String> vars, Map<String, Object> map) throws Exception {
	    for (String var : vars) {
	        String valor;
	        if (globalVars.containsKey(var) || map.containsKey(var)) {
	            try {
	              valor = map.get(var).toString();
	           }catch (Exception e) {
                  valor = "null";
               }
	            throw new IllegalArgumentException("La variable '" + var + "' ya fué creada, tiene el valor: " + valor);
	        }
	        map.put(var, null);
	        sistema.printOutput("Variable creada: " + var);
	        //System.out.println("Variable creada: " + var);
	    }
	}

	public static void assignVar(String var, String value, Map<String, Object> map) throws Exception{
        if (!globalVars.containsKey(var) && !map.containsKey(var)) {
            throw new IllegalArgumentException("La variable '" + var + "' no existe.");
        }
        Map<String, Object> map_out;
        if (globalVars.containsKey(var)) {
            map_out = globalVars;
        }else{
            map_out = map;
        }
            
        if (globalVars.containsKey(value)) {
            map_out.put(var, getVar(value, globalVars));
        }else if (map.containsKey(value)) {
            map_out.put(var, map.get(value));
        } else {
            map_out.put(var, Integer.parseInt(value));
        }
  	    sistema.printOutput("Variable asignada: " + var + " con valor: " + map_out.get(var));
        //System.out.println("Variable asignada: " + var + " con valor: " + map_out.get(var));
      }

    public static Integer getVar(String var, Map<String, Object> map) throws Exception{
        if (!globalVars.containsKey(var) && !map.containsKey(var)) {
            throw new IllegalArgumentException("La variable '" + var + "' no existe.");
        }
        if (globalVars.containsKey(var)) {
            return (Integer) globalVars.get(var);
        }else {
            return (Integer) map.get(var);
        }
    }

//Empieza aqui yo de mas tarde ;´p

//    public static void createProc(String name, Map<String, Integer> localVars, ArrayList<Map<String, Object >> instructions) {
//        for (Map<String, Object> proc : procs) {
//            if (proc.containsKey(name)) {
//                throw new IllegalArgumentException("El procedimiento '" + name + "' ya fué creado.");
//            }
//        }
//        Map<String, Object> newProc = new HashMap<>();
//        newProc.put("name", name);
//        newProc.put("localVars", localVars);
//        newProc.put("instructions", instructions);
//        procs.add(newProc);
//    }

    public static Integer createBlock(Map<Integer, ArrayList<Object > > instructions) {
          blockID++;
          Map<String, Object> block = new HashMap<>();
          Map<String, Integer> localVars = new HashMap<>();
            block.put("id", blockID);
            block.put("localVars", localVars);
            block.put("instructions", instructions);
            blocks.put(blockID, block);
            sistema.printOutput("Bloque creado con id: " + blockID);
			//System.out.println("Bloque creado con id: " + blockID);
          return blockID;
    }

    public static void executeBlock(Integer id) throws Exception{
        Map<String,Object> block = blocks.get(id);
        Map<String, Object> localVars = (Map<String, Object>) block.get("localVars");
        Map<Integer, ArrayList <Object >> instructions = (Map<Integer, ArrayList<Object >>) block.get("instructions");
        sistema.printOutput("Ejecutando bloque con id: " + id);
        //System.out.println("Ejecutando bloque con id: " + id);
        readInstructions(instructions, localVars);
    }

    public static Integer checkN(String n, Map<String, Object> map) {
        Integer n_value;
        if (globalVars.containsKey(n)) {
            n_value = (Integer) globalVars.get(n);
        }else if (map.containsKey(n)) {
            n_value = (Integer) map.get(n);
        }else {
            n_value = Integer.parseInt(n);
        }
        return n_value;
    }
    
    public static void caseGoTo(String n1, String n2, Map<String, Object> map) throws Exception{
        Integer n1_value;
        Integer n2_value;

        n1_value = checkN(n1, map);
        n2_value = checkN(n2, map);

		try { 
			world.setPostion(n1_value, n2_value);
	        } catch (Exception e) {
	          throw new IllegalArgumentException("No se puede ir a la posición (" + n1_value + ", " + n2_value + ").");
	        }
		sistema.printOutput("GOTO con valores: " + n1_value + " y " + n2_value);
        //System.out.println("GOTO con valores: " + n1_value + " y " + n2_value);
        
    }

    public static void caseMove(ArrayList<Object> out, Map<String, Object> map) throws Exception{
		Integer n;
		String operation;
		String value;
		n = checkN((String) out.get(1), map);
		ArrayList<Object> adds = (ArrayList<Object>) out.get(2);
		for (Object add : adds) {
		  if((String)add == "toThe") {
            operation = (String) add;
            value = (String) adds.get(1);
            //TODO
            sistema.printOutput("MOVE con valores: " + n + " y " + value + " y " + operation);
            //System.out.println("MOVE con valores: " + n + " y " + value + " y " + operation);
		  }else if((String)add == "inDir") {
            operation = (String) add;
            value = (String) adds.get(1);
            //TODO
            sistema.printOutput("MOVE con valores: " + n + " y " + value + " y " + operation);
            //System.out.println("MOVE con valores: " + n + " y " + value + " y " + operation);
          }else {
            operation = (String) add;
            //TODO
            sistema.printOutput("MOVE con valores: " + n + " y " + operation);
            //System.out.println("MOVE con valores: " + n + " y " + operation);
          }

         
    }
    //sistema.printOutput("MOVE con valor "+n);
	//System.out.println("MOVE con valor "+n);    
    
  }

  public static void caseTurn(String d, Map<String, Object> map) throws Exception{
	try {
	  if (d.equals("#right")) {
        world.turnRight();
      }else if (d.equals("#left")) {
        world.turnRight();
        world.turnRight();
        world.turnRight();
      }else if (d.equals("#around")) {
        world.turnRight();
        world.turnRight();
      }
	}catch (Exception e) {
	  throw new IllegalArgumentException("No se puede girar a la dirección " + d + ".");
	}
    sistema.printOutput("TURN con valor "+d);
    }

   public static void caseFace(String o, Map<String, Object> map) throws Exception{
     int faceMeta = -1;
     if (o.equals("#north")) {
       faceMeta = 0;
     }else if (o.equals("#south")) {
       faceMeta = 1;
     }else if (o.equals("#east")) {
       faceMeta = 2;
     }else if (o.equals("#west")) {
       faceMeta = 3;
     }else {
       throw new IllegalArgumentException("La dirección " + o + " no es válida.");
     }
             
//	public static final int NORTH = 0;
//	public static final int SOUTH = 1;
//	public static final int EAST = 2;
//	public static final int WEST = 3;

	while(true) {
	  int actualFace = world.getFacing();
	  if (actualFace == faceMeta) {
        break; }

      world.turnRight();
	  
	}
	
	 sistema.printOutput("FACE con valor "+o);
    }

   public static void casePick(ArrayList<Object> out, Map<String, Object> map) throws Exception{
     Integer n;
     String x;
     n = checkN((String) out.get(1), map);
     ArrayList<Object> adds = (ArrayList<Object>) out.get(2);
     x = (String) adds.get(1);
     //TODO
	 sistema.printOutput("PICK con valores: " + n + " y " + x);
    }

   public static void casePut(ArrayList<Object> out, Map<String, Object> map) throws Exception{
     Integer n;
     String x;
     n = checkN((String) out.get(1), map);
     ArrayList<Object> adds = (ArrayList<Object>) out.get(2);
     x = (String) adds.get(1);
     //TODO
     sistema.printOutput("PUT con valores: " + n + " y " + x);
    }

    public static void caseJump(ArrayList<Object> out, Map<String, Object> map) throws Exception{
      Integer n;
      String operation;
      String value;
      n = checkN((String) out.get(1), map);
      ArrayList<Object> adds = (ArrayList<Object>) out.get(2);
      for (Object add : adds) {
        if((String)add == "toThe") {
            operation = (String) add;
            value = (String) adds.get(1);
            //TODO
            sistema.printOutput("JUMP con valores: " + n + " y " + value + " y " + operation);
        }else if((String)add == "inDir") {
            operation = (String) add;
            value = (String) adds.get(1);
            //TODO
            sistema.printOutput("JUMP con valores: " + n + " y " + value + " y " + operation);
        }
      }
      //sistema.printOutput("JUMP con valor "+n);
    }

    public static void caseNop() {
      sistema.printOutput("NOP");
    }

    public static void caseLoop(ArrayList<Object> out, Map<String, Object> map) throws Exception{
      Boolean conditionVal =true;
      ArrayList<Object> condition = (ArrayList<Object>) out.get(1);
      sistema.printOutput("LOOP con valor "+condition);
      //System.out.println("LOOP con valor "+condition);
      
      while(true) {
        conditionVal = checkCondition(condition, map);
        if(!conditionVal) {
          break;
        }
        Map<Integer, ArrayList<Object>> instructions = (Map<Integer, ArrayList<Object>>) out.get(2);
        
        readInstructions(instructions, map);
      }
    }

    public static void caseConditional(ArrayList<Object> out, Map<String, Object> map) throws Exception{

      Boolean conditionVal = checkCondition((ArrayList<Object>)out.get(1), map);

	  sistema.printOutput("CONDITIONAL");
      //System.out.println("CONDITIONAL");
      if (conditionVal) {
          Map<Integer, ArrayList<Object>> instructions = (Map<Integer, ArrayList<Object>>) out.get(2);
          readInstructions(instructions, map);
      }else {
          Map<Integer, ArrayList<Object>> instructions = (Map<Integer, ArrayList<Object>>) out.get(3);
          readInstructions(instructions, map);
      }
    }

    public static Boolean checkCondition(ArrayList<Object> condition, Map<String, Object> map) throws Exception{
		String type = (String) condition.get(0);
		Boolean out = false;
      if (type.equals(FACING_C)) {
        //TODO
        sistema.printOutput("FACING_C");
          return out;
      }else if (type.equals(CAN_PUT)) {
        //TODO
        sistema.printOutput("CAN_PUT");
          return out;
      }else if (type.equals(CAN_PICK)) {
        //TODO
        sistema.printOutput("CAN_PICK");
          return out;
      }else if (type.equals(CAN_MOVE)) {
        //TODO
        sistema.printOutput("CAN_MOVE");
          return out;
      }else if (type.equals(CAN_JUMP)) {
        //TODO
        sistema.printOutput("CAN_JUMP");
          return out;
      }else if (type.equals(NOT_)) {
        sistema.printOutput("NOT_");
          return !checkCondition((ArrayList<Object>)condition.get(1), map);
      }else { 
          return false;
      }
    }

    public static void caseRepeat(ArrayList<Object> out, Map<String, Object> map) throws Exception{
		Integer n = checkN((String) out.get(1), map);
		sistema.printOutput("REPEAT con valor "+n);
		//System.out.println("REPEAT con valor "+n);
		Map<Integer, ArrayList<Object>> instructions = (Map<Integer, ArrayList<Object>>) out.get(2);
		while(true) {
		  if(n == 0) {
            break;
          }else {
            readInstructions(instructions, map);
            n--;
          }
		}
    }

    public static void caseProcedureDef(ArrayList<Object> out, Map<String, Object> map) throws Exception{
		//Falta chekear que el procedimiento no se repita
		Map<String, Object> util = (Map<String, Object>) out.get(1);
		String name = String.join("", (ArrayList<String>)util.get("name"));
		Map<Integer, ArrayList<Object>> block = (Map<Integer, ArrayList<Object>>)util.get("block");
		ArrayList<String > params = (ArrayList<String>)util.get("params");

		Map<String, Object> proc = new HashMap<>();
		proc.put("name", name);
		proc.put("block", block);
		proc.put("params", params);
		procs.put(name, proc);

		sistema.printOutput("PROCEDURE DEF con nombre: " + name + " y parametros: " + params);
		sistema.printOutput("PROCEDURE DEF con block: " + block);
		//System.out.println("PROCEDURE DEF con nombre: " + name + " y parametros: " + params);
		//System.out.println("PROCEDURE DEF con block: " + block);

      
    }

    public static void caseProcedureCall(ArrayList<Object> out, Map<String, Object> map) throws Exception{
      
      Map<String, Object> util = (Map<String, Object>) out.get(1);
      String name = String.join("", (ArrayList<String>)util.get("name"));
      ArrayList<String> params = (ArrayList<String>)util.get("params");
      if (!procs.containsKey(name)) {
          throw new IllegalArgumentException("El procedimiento '" + name + "' no existe.");
      }
      Map<String, Object> proc = (Map<String,Object >)procs.get(name);
      Map<Integer, ArrayList<Object>> block = (Map<Integer, ArrayList<Object>>)proc.get("block");
      ArrayList<String> procParams = (ArrayList<String>)proc.get("params");
	  Map<String, Object> localVars = new HashMap<>();	
      try {
        for (int i = 0; i < params.size(); i++) {
          localVars.put(procParams.get(i), checkN(params.get(i), map));
        } }catch (Exception e) {
          throw new IllegalArgumentException("El procedimiento '" + name + "' no tiene los parametros correctos.");
        }
      sistema.printOutput("PROCEDURE CALL con nombre: " + name + " y parametros: " + localVars);
      //System.out.println("PROCEDURE CALL con nombre: " + name + " y parametros: " + localVars);

      readInstructions(block, localVars);

      
    }

    public static void readInstructions(Map<Integer,ArrayList<Object >> instructions, Map<String, Object> map) throws Exception {
      for (Map.Entry<Integer, ArrayList<Object>> entry : instructions.entrySet()) {
          ArrayList<Object> instruction = entry.getValue();
          String type = (String) instruction.get(0);
          sistema.printOutput("Instrucción: " + type);
          //System.out.println("Instrucción: " + type);
          if (type.equals(CREATE_VARS)) {
              createVars((ArrayList<String>) instruction.get(1), map);
          } else if (type.equals(ASSIGN_VAR)) {
              assignVar((String) instruction.get(1), (String) instruction.get(2), map);
          }else if (type.equals(GO_TO)) {
              caseGoTo((String) instruction.get(1), (String) instruction.get(2), map);
          }else if (type.equals(MOVE_I)) {
              caseMove((ArrayList<Object>)instruction, map);
          }else if (type.equals(TURN_I)) {
              caseTurn((String) instruction.get(1), map);
          }else if (type.equals(FACE_I)) {
              caseFace((String) instruction.get(1), map);
          }else if (type.equals(PICK_I)) {
              casePick((ArrayList<Object>)instruction, map);
          }else if (type.equals(PUT_I)) {
              casePut((ArrayList<Object>)instruction, map);
          }else if (type.equals(JUMP_I)) {
              caseJump((ArrayList<Object>)instruction, map);
          }else if (type.equals(NOP_I)) {
              caseNop();
          }else if (type.equals(LOOP_C)) {
              caseLoop(instruction, map);
          }else if (type.equals(CONDITIONAL_C)) {
              caseConditional(instruction, map);
          }else if (type.equals(REPEAT_C)) {
              caseRepeat(instruction, map);
          }else if (type.equals(PROCEDURE_DEF)) {
              caseProcedureDef(instruction, map);
          }else if (type.equals(PROCEDURE_CALL)) {
              caseProcedureCall(instruction, map);
          }
      }
    }

	
    
}
PARSER_END(Robot)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN: /* palabras clave */
{
  < PROC : "proc" >
| < GOTO : "goTo" >
| < WITH : "with" >
| < TOTHE : "toThe" >
| < INDIR : "inDir" >
| < OFTYPE : "ofType" >
| < MOVE : "move" >
| < TURN : "turn" >
| < PICK : "pick" >
| < FACE : "face" >
| < PUT : "put" >
| < JUMP : "jump" >
| < NOP : "nop" >
| < IF : "if" >
| < THEN : "then" >
| < ELSE : "else" >
| < WHILE : "while" >
| < DO : "do" >
| < FOR : "for" >
| < REPEAT : "repeat" >
| < FACING : "facing" >
| < CANPUT : "canPut" >
| < CANPICK : "canPick" >
| < CANMOVE : "canMove" >
| < CANJUMP : "canJump" >
| < NOT : "not" >
}

TOKEN: /* simbolos varios */
{
  < RPAREN : ")" >
| < LPAREN : "(" >
| < PIPE : "|" >
| < RSQUARE : "]" >
| < LSQUARE : "[" >
| < COMA : "," >
| < DOT : "." >
| < ASSIGN : ":=" >
| < EQUAL : "=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < COLON : ":" >
| < SEMICOLON : ";" >
}

TOKEN: /* constantes */
{
  < NUM: (["0"-"9"])+ >
| < WORD: (["a"-"z","A"-"Z"])+ >
  
}

TOKEN: { <VARNAME: (["a"-"z","A"-"Z"])+ > }
TOKEN: { <PROCNAME: (["a"-"z","A"-"Z"])+ > }

Boolean command(Console sistema) throws Exception:
{
  createSistema(sistema);
  //salida = new String();
}
{
  (
    {
      Map<Integer,ArrayList<Object >> instructions = new LinkedHashMap<>();
      ArrayList<Object> instruction = new ArrayList<>();
    }
    (
      { ArrayList<String> vars; } vars = variable_definition()
        {
          instruction.add(CREATE_VARS);
          instruction.add(vars);
          instructions.put(getInstructionID(), instruction);
          try { readInstructions(instructions, globalVars); return true;} catch (Exception e) {return false;}
        }
      | ({ Token t; Boolean colon = false;} t = < WORD >
        (
          (
            
          
		({ ArrayList<Object> out;} out = variable_assignment(t)
		    {
		      instruction.add(ASSIGN_VAR);
		      instruction.addAll(out);
		      instructions.put(getInstructionID(), instruction);
		      try { readInstructions(instructions, globalVars);} catch (Exception e) {return false;}
		    })
		  | ({ Map<String, Object > out; } out = procedure_call(t)
        
          {
            
		      instruction.add(PROCEDURE_CALL);
		      instruction.add(out);
		      instructions.put(getInstructionID(), instruction);
		      try { readInstructions(instructions, globalVars);} catch (Exception e) {return false;}
		  })

		    )
          
        )
      )
        
//	| { ArrayList<Object> out; Token t; } t = < WORD > out = variable_assignment(t)
//	    {
//	      instruction.add(ASSIGN_VAR);
//	      instruction.addAll(out);
//	      instructions.put(getInstructionID(), instruction);
//	      readInstructions(instructions, globalVars);
//	    }
//
//	| { Map<String,Object> out; Token t; } (t = < WORD >) out = procedure_call(t)
//	  {
//	    instruction.add(PROCEDURE_DEF);
//        instruction.add(out);
//        instructions.put(getInstructionID(), instruction);
//        readInstructions(instructions, globalVars);
//      }
	| { Map<String, Object > out; } out = procedure_definition()
	  {
	    instruction.add(PROCEDURE_DEF);
	    instruction.add(out);
	    instructions.put(getInstructionID(), instruction);
	    try { readInstructions(instructions, globalVars);} catch (Exception e) {return false;}
	  }
	| { Map<Integer, ArrayList<Object>> out;} out = block()
	  {
	    Integer id = createBlock(out);
	    try { executeBlock(id);} catch (Exception e) {return false;}
	    
	  }
    )
    {
      //sistema.printOutput(salida);
	  return true;
    }
  )+
  | <EOF> {return false;} 
}


ArrayList<String> variable_definition():
{
  ArrayList<String> vars = new ArrayList<String>();
  Token t;
}
{
  < PIPE >
  (
    t = < WORD > { vars.add(t.image); }
  )*
  < PIPE >
  {
    return vars;
  }
}

Map<String, Object> procedure_definition():
//void procedure_definition():
{
  Token t;
  Token v;
  ArrayList<String> name = new ArrayList<String>();
  ArrayList<String> params = new ArrayList<String>();
  Map<Integer, ArrayList<Object>> block;
  Map<String, Object> out = new HashMap<>();
}
{
  < PROC >
  (
	t = <WORD> { name.add(t.image); }
	    (
	       // Si justo después del primer WORD hay un COLON, se espera que siga un WORD
	       <COLON> ( v = <WORD> ) { params.add(v.image); }
	    )?
	    (
	       // Luego, mientras se observe que hay otro par (señalado por un WORD seguido de COLON)
	       //LOOKAHEAD( <WORD> <COLON> )
	       t = <WORD> <COLON> (v = <WORD>) { name.add(t.image); params.add(v.image); }
	    )*
  )
  block = block()
  {
    out.put("name", name);
    out.put("params", params);
    out.put("block", block);
    return out;
  }
}

//Map<String, Integer> localVars, ArrayList<Map<String, Object >> instructions
Map<Integer, ArrayList<Object>> block():
{
  Map<Integer, ArrayList<Object>> instructions = new LinkedHashMap<>();
  //ArrayList<Object> instruction = new ArrayList<>();
}
{
  < LSQUARE >
  (
      (
	    { ArrayList<String> vars; } vars = variable_definition()
	      {
	        ArrayList<Object> instruction = new ArrayList<>();
	        instruction.add(CREATE_VARS);
	        instruction.add(vars);
	        instructions.put(getInstructionID(), instruction);
	      }
//	  | { ArrayList<Object> assign; } assign = variable_assignment()
//	      {
//	        ArrayList<Object> instruction = new ArrayList<>();
//	        instruction.add(ASSIGN_VAR);
//	        instruction.addAll(assign);
//	        instructions.put(getInstructionID(), instruction);
//	      } 
//	  | procedure_call()
      |(
        { Token t; }t = < WORD >
        (
          { ArrayList<Object> assign; } assign = variable_assignment(t)
          {
            ArrayList<Object> instruction = new ArrayList<>();
	        instruction.add(ASSIGN_VAR);
	        instruction.addAll(assign);
	        instructions.put(getInstructionID(), instruction);
          }
        | 
            { Map<String, Object > out; } out = procedure_call(t)
            {
            ArrayList<Object> instruction = new ArrayList<>();
            instruction.add(PROCEDURE_DEF);
            instruction.add(out);
            instructions.put(getInstructionID(), instruction);
            }
          )
       )
	  | { ArrayList<Object> out; } out = repeat()
        {
          ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(REPEAT_C);
          instruction.addAll(out);
          instructions.put(getInstructionID(), instruction);
        }
	  | { ArrayList<Object> out; } out = conditional()
	    {
	      ArrayList<Object> instruction = new ArrayList<>();
	      instruction.add(CONDITIONAL_C);
          instruction.addAll(out);
          instructions.put(getInstructionID(), instruction);
	    }
	  | { ArrayList<Object> out; } out = loop()
	    {
	      ArrayList<Object> instruction = new ArrayList<>();
	      instruction.add(LOOP_C);
          instruction.addAll(out);
          instructions.put(getInstructionID(), instruction);
	    }
	  | { ArrayList<Object> outGoTo; } outGoTo = goTo()
	    {
	      ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(GO_TO);
          instruction.addAll(outGoTo);
          instructions.put(getInstructionID(), instruction);
	    }
	  | { ArrayList<Object>out; } out = move()
	    {
	      ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(MOVE_I);
          instruction.addAll(out);
          instructions.put(getInstructionID(), instruction);
	    }
	  | { String out; } out = turn()
	    { 
          ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(TURN_I);
          instruction.add(out);
          instructions.put(getInstructionID(), instruction);
        }
	  | { String out;} out = face()
	    { 
          ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(FACE_I);
          instruction.add(out);
          instructions.put(getInstructionID(), instruction);
        }
	  | { ArrayList<Object> out; } out = pick()
	    {
	      ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(PICK_I);
          instruction.addAll(out);
          instructions.put(getInstructionID(), instruction);
	    }
	  | { ArrayList<Object> out; } out = put()
	    {
	      ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(PUT_I);
          instruction.addAll(out);
          instructions.put(getInstructionID(), instruction);
	    }
	  | { ArrayList<Object> out; } out = jump()
	    {
	      ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(JUMP_I);
          instruction.addAll(out);
          instructions.put(getInstructionID(), instruction);
	    }
	  | nop()
	    {
	      ArrayList<Object> instruction = new ArrayList<>();
          instruction.add(NOP_I);
          instructions.put(getInstructionID(), instruction);
	    }
	  )
  )*
  < RSQUARE >
  {    
    return instructions;
  }
}


ArrayList<Object> variable_assignment(Token var):
{
  ArrayList<Object> out = new ArrayList<Object>();
//  Token var;
  Token value;
}
{
  (
//      var = < WORD >
	  < ASSIGN >
	  value = N()
	  <DOT>
  )
  {
    out.add(var.image);
    out.add(value.image);
    return out;
  }
}


ArrayList<Object> goTo():
{
  Token n1;
  Token n2;
}
{
  < GOTO >
  < COLON >
  n1 = N()
  < WITH >
  < COLON >
  n2 = N()
  < DOT >
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(n1.image);
    out.add(n2.image);
    return out;
  }
}

Token N():
{
  Token t;
}
{
  (
    t = < NUM > 
  | t = < WORD >
  )
{
  return t;
}
}

String D_turn():
{
  Token t;
}
{
  (
    t = "#right"
  | t = "#left"
  | t = "#around"
  ) { return t.image; }
}

String D():
{
  Token t;
}
{
  (
    t = "#front"
  | t = "#right"
  | t = "#left"
  | t = "#back"
  ) { return t.image; }
}

String O():
{
  Token t;
}
{
  (
    t = "#north"
  | t = "#south"
  | t = "#east"
  | t = "#west"
  ) { return t.image; }
}

String X():
{
  Token t;
}
{
  (
    t = "#balloons"
  | t = "#chips"
  ) { return t.image; }
}

void variable():
{
}
{
  < VARNAME >
}

ArrayList<Object > toThe():
{
  Token t;
  String d;
}
{
  t = < TOTHE >
  < COLON >
  d = D()
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(t.image);
    out.add(d);
    return out;
  }
}

ArrayList<Object> inDir():
{
  Token t;
  String o;
}
{
  t = < INDIR >
  < COLON >
  o = O()
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(t.image);
    out.add(o);
    return out;
  }
}

ArrayList<Object> ofType():
{
  Token t;
  String x;
}
{
  t = < OFTYPE >
  < COLON >
  x = X()
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(t.image);
    out.add(x);
    return out;
  }
}

ArrayList<Object> move():
{
  Token n;
  ArrayList<Object> out = new ArrayList<Object>();
}
{
  < MOVE >
  < COLON >
  n = N()
  (
    out = inDir()
    | out = toThe()
  )?
  < DOT >
  {
    ArrayList<Object> out2 = new ArrayList<>();
    out2.add(n.image);
    out2.add(out);
    return out2;
  }
}

String turn():
{
  String d;
}
{
  < TURN >
  < COLON >
  d = D_turn()
  < DOT >
  {
    return d;
  }
}

String face():
{
  String o;
}
{
  < FACE >
  < COLON >
  o = O()
  < DOT >
  {
    return o;
  }
}

ArrayList<Object> put():
{
  Token n;
  ArrayList<Object> of = new ArrayList<Object>();
}
{
  < PUT >
  < COLON >
  n = N()
  of = ofType()
  < DOT >
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(n.image);
    out.add(of);
    return out;
  }
}

ArrayList<Object> pick():
{
  Token n;
  ArrayList<Object> of = new ArrayList<Object>();
}
{
  < PICK >
  < COLON >
  n = N()
  of = ofType()
  < DOT >
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(n.image);
    out.add(of);
    return out;
  }
}

ArrayList<Object> jump():
{
  Token n;
  ArrayList<Object> out = new ArrayList<Object>();
}
{
  < JUMP >
  < COLON >
  n = N()
  (
    out = inDir() | out = toThe()
  )
  < DOT >
  {
    ArrayList<Object> out2 = new ArrayList<>();
    out2.add(n.image);
    out2.add(out);
    return out2;
  }
}

void nop():
{
}
{
  < NOP >
  < DOT >
}

ArrayList<Object> conditional():
{
  ArrayList<Object> condition;
  Map<Integer, ArrayList<Object>> block1;
  Map<Integer, ArrayList<Object>> block2;
}
{
  < IF >
  < COLON >
  condition = condition()
  < THEN >
  < COLON >
  block1 = block()
  (
    < ELSE >
    < COLON >
    block2 = block()
  )
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(condition);
    out.add(block1);
    out.add(block2);
    return out;
  }
}

ArrayList<Object> loop():
{
  ArrayList<Object> instruction_ff = new ArrayList<Object>();
  ArrayList<Object> condition;
  Map<Integer, ArrayList<Object>> instructions;
}
{
  < WHILE >
  < COLON >
  condition = condition()
  < DO >
  < COLON >
  instructions = block()
  {
    instruction_ff.add(condition);
    instruction_ff.add(instructions);
    return instruction_ff;
  }
}

ArrayList<Object> repeat():
{
  ArrayList<Object> out = new ArrayList<Object>();
  Token n;
  Map<Integer, ArrayList<Object>> block;
}
{
  < FOR >
  < COLON >
  n = N()
  < REPEAT >
  < COLON >
  block = block()
  {
    out.add(n.image);
    out.add(block);
    return out;
  }
}

ArrayList<Object> condition():
{
  ArrayList<Object> out2 = new ArrayList<Object>();
  
}
{(
  { String out; } out = facing()
  {
    out2.add(FACING_C);
    out2.add(out);
  }
| {  ArrayList<Object> out; } out = canPut()
  {
    out2.add(CAN_PUT);
    out2.addAll(out);
  }
| {  ArrayList<Object> out; } out = canPick()
  {
    out2.add(CAN_PICK);
    out2.addAll(out);
  }
| {  ArrayList<Object> out; } out = canMove()
  {
    out2.add(CAN_MOVE);
    out2.addAll(out);
  }
| {  ArrayList<Object> out; } out = canJump()
  {
    out2.add(CAN_JUMP);
    out2.addAll(out);
  }
| {  ArrayList<Object> out; } out = not()
  {
    out2.add(NOT_);
    out2.addAll(out);
  })
  {
    return out2;
  }
}

String facing():
{
  String o;
}
{
  < FACING >
  < COLON >
  o = O()
  < DOT >
  {
    return o;
  }
}

ArrayList<Object> canPut():
{
  Token n;
  ArrayList<Object> of = new ArrayList<Object>();
}
{
  < CANPUT >
  < COLON >
  n = N()
  of = ofType()
  < DOT >
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(n.image);
    out.add(of);
    return out;
  }
}

ArrayList<Object> canPick():
{
  Token n;
  ArrayList<Object> of = new ArrayList<Object>();
}
{
  < CANPICK >
  < COLON >
  n = N()
  of = ofType()
  < DOT >
  {
    ArrayList<Object> out = new ArrayList<Object>();
    out.add(n.image);
    out.add(of);
    return out;
  }
}

ArrayList<Object> canMove():
{
  Token n;
  ArrayList<Object> out = new ArrayList<Object>();
}
{
  < CANMOVE >
  < COLON >
  n = N()
  (
    out = inDir() | out = toThe()
  )
  < DOT >
  {
    ArrayList<Object> out2 = new ArrayList<Object>();
    out2.add(n.image);
    out2.add(out);
    return out2;
  }
}

ArrayList<Object> canJump():
{
  Token n;
  ArrayList<Object> out = new ArrayList<Object>();
}
{
  < CANJUMP >
  < COLON >
  n = N()
  (
    out = inDir() | out = toThe()
  )
  < DOT >
  {
    ArrayList<Object> out2 = new ArrayList<Object>();
    out2.add(n.image);
    out2.add(out);
    return out2;
  }
}

ArrayList<Object> not():
{
  ArrayList<Object> out = new ArrayList<Object>();
}
{
  < NOT >
  < COLON >
  out = condition()
  {
    return out;
  }
}


Map<String,Object> procedure_call(Token t2):
{
  ArrayList<Object> name = new ArrayList<Object>();
  ArrayList<String> params = new ArrayList<String>();
  Map<String, Object> out = new HashMap<>();
  Token t;
  Token n;
}
{
  /*t = <WORD>*/ { name.add(t2.image); }
      ( <  COLON > n = N() { params.add(n.image); } )?
      (
         LOOKAHEAD( <WORD> <COLON> )
         t = <WORD> <COLON> n = N() { name.add(t.image); params.add(n.image); }
      )*
  <DOT>
  {
    out.put("name", name);
    out.put("params", params);
    return out;
  }
}





